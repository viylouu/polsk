// Meanings
// Span op:
//     a type of operator that consists of some rules to determine what it contains as an alternative to grouping
// Keeping spans intact:
//     basically rules for spans that if you break, the program will fail to compile


// Variable Declarations

// declare a variable using the "⌞" unary op
⌞x
// where x is the variable name
// you can then assign a value to x using the "=" infix op
x = 5
// or you could define, and assign on the same line
⌞x = 5
// this would be parsed like this
(⌞ (x)) = (5)
// or with keywords
(define (x)) assign (5)
// due to the nature of the language, you can do stuff like this!
= 5 x⌞
// weird right?
// well this parses just like this
assign (5) ((x) define)
// reads just like... almost like english! but its simple!
// if i just format it like a regular language, then its easy to read
assign(5, define(x))
// one thing to note: the parser parses stuff from left to right
// you can't do this for semi-obvious reasons though
⌞5 = x
// the definition operator doesent accept literals!

// Conditionals

// in polsk, we have a "few" conditionals
// heres a list
// -------------------------------------
// | SYMBOL | MEANING                  |
// | ≡      | strict equals            |
// | ≈      | loose equals             |
// | ≢      | strict not equals        |
// | ≉      | loose not equals         |
// | <      | less than                |
// | >      | greater than             |
// | ≤      | less than or equal to    |
// | ≥      | greater than or equal to |
// | ⊂      | subset                   |
// | ⊃      | superset                 |
// | ⊄      | not subset               | 
// | ⊅      | not superset             |
// | ∈      | contains                 |
// | ∉      | does not contain         |
// -------------------------------------
// the "joining comparisons" (idk what these are called)
// -----------------------------------------------------------------
// | SYMBOL | TYPE  | MEANING                                      |
// | ∧      | infix | and                                          |
// | ∨      | infix | or                                           |
// | ⊼      | infix | nand                                         |
// | ⊽      | infix | nor                                          |
// | ⊻      | infix | exclusive or                                 |
// | ¬      | unary | not                                          |
// | ⇒      | infix | implies (if A is true, then B is true)       |
// | ⇐      | infix | is implied by (if B is true, then A is true) |
// | ⇔      | infix | iff (true if A and B match)                  |
// -----------------------------------------------------------------

// Using Data Transformers (or Functions)

// data transformers are like functions, except every parameter is a reference that gets changed (maybe) when you use it in the function
// for example, you can print the value of x like this
print ;λx
// where the ; post op is used to denote a parameter group
// and the λ op is used to denote a parameter

// Defining Data Transformers

// create a data transformer using the "ƒ" span op
ƒdouble ;λx
// this one is a little complicated
// ƒ takes in a name, and a parameter group
// heres how you mutate input
ƒdouble ;λx = λx * 2
// to mutate an input, you just use the λ op (special op) to signify you are modifying it instead of just using it
// NOTE: to keep the span intact, keep the = to the right of ƒ
// mutli line functions
ƒfibb ;λn =
    ? n ≤ 1
        ↵
    : 
        ⌞nm1 = n - 1
        ⌞nm2 = n - 2
        λn = fibb ;λnm1 + fibb ;λnm2
// here we do have one new concept: ↵
// this is a unique one because it has no inputs!
// all it is is just an early return

// Parameter Groups

// parameter groups are used as input to functions
// you can define a parameter group like this
; λparam1 λparam2 λetc
// using the ; span op for the start, and denoting each parameter with λ
// you can have optional parameters too using the ~ unary op
; λparam1 λparam2 λ~optional
// it must be placed after the λ though to keep the span intact
// if the optional parameter isnt given, it's assigned nil

// Control Flow

// this language has no if statements other than ternary ops!
// ternary ops consist of the span op ?
// and the infix op :
// heres an example
? true func1 : func2
// you can actually use this to make your own rudimentary if statement!
ƒif ;λcond λthen λ~else = ? cond then : else

// Loops

// while polsk has no loops, you can create your own using recursion
ƒwhile ;λcond_f λfunc = 
    ⌞v
    cond_f ;λv
    ?v func : ↵
// something like that

// Macros

// macros are defined very similar to functions
// the only difference is they use the "µ" span op instead of "ƒ"
// heres an example
µswap ;λx λy =
    ⌞temp = x
    λx = y
    λy = temp
// NOTE: just like ƒ, to keep the span intact, keep the = to the right of µ

